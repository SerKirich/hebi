Программирование микроконтроллеров Arduino на языке Hebi
========================================================

## Содержание

* Введение
* Установка
* Запуск
* Язык Hebi
  * Структура программы
  * Система типов
  * Переменные
  * Выражения
  * Операторы
  * Функции
  * События
  * Внешние определения
* Заключение

## Введение

Различные микроконтроллеры используются сегодня повсюду: от микроволновых печей у нас дома до сложных станков на заводах. Также их используют школьники и студенты для реализации своих проектов. Наиболее популярны для таких задач микроконтроллеры Arduino, но программы для них пишутся на диалекте языка C++ и в основном в процедурном стиле. Я считаю, что для микроконтроллеров более естественна событийно-ориентированная парадигма программирования, так как их задача - реагировать на "события" реального мира.

Для решения проблемы я создал Hebi - событийно-ориентированный язык программирования микроконтроллеров Arduino.

## Установка

Hebi поставляется в виде архива `hebi.tar.gz`.

Для установки Hebi необходимы следующие пакеты:
  * GNU Make
  * Haskell Platform
  * Arduino IDE

На Ubuntu Linux их можно установить следующим образом:

```
$ sudo apt-get update
$ sudo apt-get install make haskell-platform arduino
```

Также необходима библиотека optparse-applicative. При условии наличия в системе перечисленных выше пакетов её можно установить так:

```
$ cabal uptate
$ cabal install optparse-applicative
```

Установить Hebi из архива можно следующим образом:

```
$ tar xfz hebi.tar.gz
$ cd Hebi
$ make
$ sudo make install
```

Удалить Hebi из системы можно так:

```
$ sudo make uninstall
```

## Запуск

Запуск Hebi должен производиться следующим образом:

```
hebi <команда> <параметры команды>
```

В настоящий момент поддерживаются следующие команды:
  * `compile`
  * `upload`

### Команда `compile`

Данная команда полезна для отладки: Hebi выполняет перевод из Hebi в Arduino C++ и компиляцию в формат Intel HEX, не удаляя при этом промежуточные файлы.

Используется следующим образом:

```
hebi compile <ИМЯ ФАЙЛА> --board=<МОДЕЛЬ ARDUINO>
```

В настоящий момент `<МОДЕЛЬ ARDUINO>` может принимать одно из следующих значений:
  * `uno`

Также можно вообще не указывать параметр `--board`, в таком случае его значением будет `uno`:

```
hebi compile <ИМЯ ФАЙЛА>
```

Параметр `--board` также имеет короткое имя `-b`, то есть допустима и такая форма команды:

```
hebi compile <ИМЯ ФАЙЛА> -b <МОДЕЛЬ ARDUINO>
```

** Обратите внимание на отсутствие `=` после `-b`! **

### Команда `upload`

Используется для загрузки программ на Hebi в память микроконтроллера.

Применяется следующим образом:

`hebi upload <ИМЯ ФАЙЛА> --board=<МОДЕЛЬ ARDUINO> --port=<ПОСЛЕДОВАТЕЛЬНЫЙ ПОРТ>`

Параметр `--port` также имеет короткое имя `-p`.

## Язык Hebi

### Структура программы

В общем случае, программа на Hebi выглядит следующим образом:

```
внешние_объявления

определения

регистрации_событий
```

Данный порядок нарушать нельзя.

### Система типов

Система типов Hebi немного отличается от системы типов C++, поэтому данную главу пропускать не рекомендуется.

#### Целые числа

Hebi оперирует следующими целочисленными типами:
  * `int8`   - 8-битное целое
  * `uint8`  - 8-битное целое беззнаковое
  * `int16`  - 16-битное целое
  * `uint16` - 16-битное целое беззнаковое
  * `int32`  - 32-битное целое
  * `uint32` - 32-битное целое беззнаковое

Их значения записываются как целые числа в десятичном виде, например:

```
uint8 x = 42;
int16 y = 0;
int32 z = -1000;
```

Значения данных типов поддерживают следующие операции:
  * `a + b`  - сложение
  * `a - b`  - вычитание
  * `a * b`  - умножение
  * `a / b`  - деление (дробная часть отбрасывается)
  * `a % b`  - остаток от деления `a` на `b`
  * `-a`     - противоположное к `a`
  * `a & b`  - побитовое "И"
  * `a | b`  - побитовое "ИЛИ"
  * `a ^ b`  - побитовое исключающее "ИЛИ"
  * `a << b` - побитовый сдвиг влево
  * `a >> b` - побитовый сдвиг вправо
  * `~a`     - побитовое "НЕ"
  * `a > b`  - `a` больше `b`
  * `a < b`  - `a` меньше `b`
  * `a >= b` - `a` больше или равно `b`
  * `a <= b` - `a` меньше или равно `b`
  * `a == b` - `a` равно `b`
  * `a != b` - `a` не равно `b`
  * `&a`     - взятие адреса

#### Числа с плавающей точкой

Для представления чисел с плавающей точкой используются значения типа `float`.

Они записываются как десятичная дробь, например:

```
float x = 42.42;
float y = 42.0; // Мантисса обязана присутствовать
float z = -1234.5678;
```

Значения типа `float` поддерживают следующие операции:
  * `a + b`  - сложение
  * `a - b`  - вычитание
  * `a * b`  - умножение
  * `a / b`  - деление
  * `a > b`  - `a` больше `b`
  * `a < b`  - `a` меньше `b`
  * `a >= b` - `a` больше или равно `b`
  * `a <= b` - `a` меньше или равно `b`
  * `a == b` - `a` равно `b`
  * `a != b` - `a` не равно `b`
  * `&a`     - взятие адреса

#### Логические значения

В качестве типа логических значений используется тип `bool`.

Он имеет всего два значения:

```
bool x = true;  // Истина
bool y = false; // Ложь
```

Значения типа `bool` поддерживают следующие операции:
  * `a && b` - логическое "И"
  * `a || b` - логическое "ИЛИ"
  * `!a`     - логическое "НЕ"
  * `a == b` - `a` равно `b`
  * `a != b` - `a` не равно `b`
  * `&a`     - взятие адреса

#### Символьные значения

Для представления символьных значений используется тип `char`.

Значения данного типа записываются так же, как в Arduino C++:

```
char x = 'x';
char y = '\n';
```

Значения типа `char` поддерживают следующие операции:
  * `a > b`  - `a` больше `b`
  * `a < b`  - `a` меньше `b`
  * `a >= b` - `a` больше или равно `b`
  * `a <= b` - `a` меньше или равно `b`
  * `a == b` - `a` равно `b`
  * `a != b` - `a` не равно `b`
  * `&a`     - взятие адреса

#### Указатели

Указатели хранят адреса переменных в памяти микроконтроллера. Тип указателя на переменную типа `t` обозначается как `t*`.

Указатели поддерживают следующие операции:
  * `a[b]` - индексация
  * `*a`   - разыменовывание
  * `&a`   - взятие адреса

#### Строки

Строки в Hebi являются массивами символов, завершающимися `\0`:

```
char *s1 = { 'H', 'e', 'b', 'i', '\0' };
char *s2 = "Hebi"; // То же самое, что и s1
```

#### Тип `pin`

Значения этого типа служат для представления пинов микроконтроллера, например:

```
pin x = D4; // Цифровой (Digital) пин №4
pin y = A2; // Аналоговый (Alanog) пин №2
```

#### Тип `void`

Тип `void` используется в том случае, когда функция не возвращает никаких значений, например:

```
void f(bool x) {
  digitalWrite(D0, x);
}
```

#### Приведения типов

Приведение типа выражения `x` к типу `t` обозначается как `t(x)`. В отличие от Arduino С++, Hebi не поддерживает неявные приведения типов - это позволяет избежать многих ошибок, особенно начинающим программистам. Поэтому все приведения типов должны выполняться явно:

```
float *p = ...;
float *q = ...;

p + q; // Нельзя

uint16(p) + uint16(q); // Можно
```

** Ответственность за корректность приведения типов лежит на программисте! **

### Переменные

Переменные объявляются следующим образом:

```
тип имя = начальное_значение;
```

Например:

```
int x = 42;
```

После объявления переменной может быть присвоено новое значение:

```
int x = 0;
x = 42;
```

Также можно объявить массив:

```
uint8 *ps = { 2, 3, 5, 7 }; // Массив на 4 элемента
```

Изменение значений массива осуществляется только через индексацию указателя на него:

```
bool *sensorsOnline = { false, false, false };
sensorsOnline[0] = true; // Индексация начинается с нуля
```

### Выражения

Выражениями являются:
  * Значения
  * Имена переменных
  * Операции
  * Вызовы функций
  * Приведения типов
  * Выражения в скобках

Кроме того, существуют т. н. условные выражения.

Например, следующая конструкция является выражением:

```
42 + x * f(1, true) - uint8(20.0) + (2 + 2) * 2
```

#### Условные выражения

Условные выражения имеют следующий вид:

```
if условие then выражение_1 else выражение_2
```

Если `условие` истинно, то значением всего выражения становится `выражение_1`, иначе `выражение_2`. `условие` должно иметь тип `bool`, а `выражение_1` и `выражение_2` - произвольные, но равные типы.

Например, следующая конструкция представлет из себя условное выражение:

```
if x == 0 then 42 else x + 2
```

### Операторы

Операторами являются:
  * Выражения
  * Объявления переменных
  * Присваивания переменным значений

Кроме того, существуют операторы
  * Ветвления
  * Цикла
  * Передачи управления

Каждый оператор должен завершаться либо `;`, либо блоком.

#### Блоки операторов

Один или несколько операторов могут быть объединены в блок. Например:

```
здесь_нужен_блок { // Здесь блок начинается с '{'...
  оператор
  оператор
  ...
} // ...и заканчивается на '}'.

здесь_нужен_блок: оператор // Всего один оператор в блоке

здесь_нужен_блок { оператор } // Тоже допустимо

здесь_нужен_блок {} // Пустой блок
```

Более конкретный пример:

```
if x > 100: move(LEFT, 10);
else {
  x = 0;
  move(RIGHT, 10);
}
```

#### Операторы ветвления

Операторы ветвления имеют следующий вид:

```
if условие блок_1 else блок_2
```

Если `условие` истинно, тогда выполняется `блок_1`, иначе `блок_2`. `блок_2` может быть опущен, в таком случае он считается пустым:

```
if x == 0: x = 1;
if x == 0: x = 1; else {} // То же самое
```

#### Операторы цикла

Операторы цикла выглядят следующим образом:

```
while условие блок
```

`блок` будет выполняться до тех пор, пока `условие` истинно.

#### Операторы передачи управления

##### Операторы возврата из функции

Операторы возврата из функции имеют следующий вид:

```
return выражение;
```

Подробнее о них рассказывается в разделе "Функции".

##### Операторы условий событий

Операторы условий событий выглядят следующим образом:

```
when выражение;
```

Подробнее о них рассказывается в разделе "События".

##### Операторы управления циклами

Существует два оператора управления циклами:

```
break;
```

и

```
continue;
```

Первый влечёт выход из цикла, а второй - новую итерацию.

### Функции

Объявления функций выглядят следующим образом:

```
тип имя(формальные_параметры) тело
```

Если функция не должна возвращать значение, `тип` должен быть `void`. В противном случае в её теле должен присутствовать оператор `return` и тип переданного ему выражения должен совпадать с типом функции. Формальные параметры перечисляются через `,`.

Приведём в пример несколько определений функций:

```
float min(float a, float b) {
  if a < b: return a;
  else:     return b;
}

void blink() {
  digitalWrite(D13, HIGH);
  delay(100);
  digitalWrite(D13, LOW);
}
```

Используя условное выражение, функцию `min` можно записать короче:

```
float min(float a, float b): return if a < b then a else b;
```

Вызов функции осуществляется следующим образом:

```
имя(фактические_параметры)
```

При этом фактические параметры должны быть перечислены через `,`. Также их количество и типы должны соответствовать количеству и типам формальных параметров.

Рекурсивные функции допустимы, но не рекомендуются к использованию, так как возможно переполнение стека микроконтроллера. Определить рекурсивную функцию можно, например, так:

```
uint16 factorial(uint16 x) {
  if x == 0: return 1;
  else:      return x * factorial(x - 1);
}
```

### События

Главное отличие Hebi от Arduino C++ - наличие событий.

** Событие - это структура, содержащая обработчик и условие его выполнения. **

События определяются следующим образом:

```
event имя(формальные_параметры) {
  переменные_состояния
  invoked условие
  handle обработчик
}
```

Пояснение на конкретном примере. Допустим, нужно написать программу управления светильником: он должен включаться, когда темно, и выключаться, когда светло. События данной программы можно определить так:

```
event DarkEvent(pin sensor, pin light, uint16 border) {
  invoked: when analogRead(sensor) < border; // Когда слишком темно...
  handle: digitalWrite(light, HIGH); // ...включаем светильник.
}

event LightEvent(pin sensor, pin light, uint16 border) {
  invoked: when analogRead(sensor) > border; // Когда светло...
  handle: digitalWrite(light, LOW); // ...выключаем его.
}
```

Обратите внимание на оператор `when`: в описании условия события следует использовать именно его вместо оператора `return`.

Получилась достаточно короткая и понятная программа, если же использовать переменные состояния, можно дополнительно её оптимизировать, уместив всё в одно событие:

```
event LightEvent(pin sensor, pin light, uint16 border) {
  bool isOn = false; // Включён ли светильник?

  invoked {
    if isOn: when analogRead(sensor) > border; // Если да, то реагируем на высокую освещённость,
    else:    when analogRead(sensor) < border; // если нет - на низкую.
  }

  handle {
    if isOn: digitalWrite(light, LOW);  // Если включён, то выключаем,
    else:    digitalWrite(light, HIGH); // если выключен - включаем.

    isOn = !isOn; // Меняем состояние.
  }
}
```

Чтобы использовать событие, его надо не только объявить, но и зарегистрировать. Регистрация события выглядит так:

```
register имя(фактические_параметры);
```

Событие `LightEvent` тогда можно зарегистрировать таким образом:

```
register LightEvent(A0, D8, 410);
```

Стоит отметить, что, хотя Hebi и избавляет программиста от написания функции `loop`, функцию `setup` всё ещё необходимо определять:

```
void setup() {
  pinMode(A0, INPUT);
  pinMode(D8, OUTPUT);
}
```

В таком случае, полный текст программы будет выглядеть следующим образом:

```
#include arduino

event LightEvent(pin sensor, pin light, uint16 border) {
  bool isOn = false;

  invoked {
    if isOn: when analogRead(sensor) > border;
    else:    when analogRead(sensor) < border;
  }

  handle {
    if isOn: digitalWrite(light, LOW);
    else:    digitalWrite(light, HIGH);

    isOn = !isOn;
  }
}

void setup() {
  pinMode(A0, INPUT);
  pinMode(D8, OUTPUT);
}

register LightEvent(A0, D8, 410);
```

Для сравнения приведём текст аналогичной программы на Arduino C++:

```
void setup() {
  pinMode(A0, INPUT);
  pinMode(8, OUTPUT);
}

void loop() {
  static boolean isOn = false;

  if (isOn && analogRead(A0) > 410) {
    digitalWrite(8, LOW);
    isOn = !isOn;
  } else if (!isOn && analogRead(A0) < 410) {
    digitalWrite(8, HIGH);
    isOn = !isOn;
  }
}
```

Она получилась короче, чем на Hebi. Однако если необходимо управлять не одним, а несколькими светильниками, причём с разными пороговыми значениями освещённости, использование средств Hebi будет предпочтительнее, так как программа на Arduino C++ будет разрастаться гораздо быстрее.

Добавить управление ещё одним светильником в программу на Hebi можно следующим образом:

```
register LightEvent(A0, D8, 410);
register LightEvent(A1, D9, 501); // Ещё один светильник
```

Обычно такая проблема решается при помощи объектно-ориентированного программирования (ООП). Например, ту же программу можно переписать так:

```
class Light {
  int sensor, light, border;
  boolean isOn;

public:
  Light(int s, int l, int b) {
    sensor = s;
    light  = l;
    border = b;
    isOn   = false;
  }

  void iterate() {
    if (isOn && analogRead(sensor) > border) {
      digitalWrite(light, LOW);
      isOn = !isOn;
    } else if (!isOn && analogRead(sensor) < border) {
      digitalWrite(light, HIGH);
      isOn = !isOn;
    }
  }
};

Light l1(A0, D8, 410);
Light l2(A1, D9, 501);

void setup() {
  pinMode(A0, INPUT);
  pinMode(A1, INPUT);
  pinMode(8, OUTPUT);
  pinMode(9, OUTPUT);
}

void loop() {
  l1.iterate();
  l2.iterate();
}
```

Но при этом использование ООП неэффективно расходует ресурсы микроконтроллера. Эта проблема решается в Hebi трансляцией событий в процедурный код.

### Внешние объявления

В том случае если необходимые переменные или функции определены в Arduino C++, их можно использовать в Hebi, предварительно объявив их внешними:

```
extern тип имя_переменной;
extern тип имя_функции(типы_аргументов);
```

Например:

```
extern float sin(float);
```

## Заключение

Программирование на Hebi лишено недостатков как процедурного, так и объектно-ориентированного подхода, при этом использует преимущества обоих.

Идея событийно-ориентированного программирования микроконтроллеров не нова: в частности, для Arduino существуют библиотеки [Arduino Event Manager](https://github.com/arcturial/arduino-event) и [Eventually](https://github.com/johnnyb/Eventually), но их недостаток в том, что события определяются как классы, что увеличивает сложность программы. Также в этих библиотеках события хранятся в дополнительной структуре данных, такой как массив или стек, что занимает лишнюю память.
